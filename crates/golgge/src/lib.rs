use bon::Builder;
use egg::{Analysis, EGraph, Id, Language, Runner};

/// A macro for tracing messages if tracing is enabled in the program's configuration.
macro_rules! mtrace {
    ($s:ident, $kind:ident, $($t:tt)*) => {
        if $s.is_tracing_enabled($crate::DebugLevel::$kind) {
          eprintln!($($t)*)
        }
    };
}

/// Defines traits and structures for working with e-graph rules.
mod rule;
pub use rule::{DRule, Dependancy, Fresh, PrologRule, Rule};

/// Provides utilities for simplifying `and` expressions in e-graphs.
mod simplify_and;
pub use simplify_and::{WithAnd, WithTrue, and_simpl_rewrite};

/// Defines structures for weighting e-graph nodes.
mod weight;
pub use weight::MWeight;

/// Provides analysis capabilities for e-graphs.
mod analysis;
pub use analysis::{MAnalysis, WeightedAnalysis};
pub use program::Program;
/// Defines structures for representing e-graph programs.
mod program;

/// Provides structures for representing proofs generated by the e-graph.
mod proof;
pub use proof::ProofItem;

mod config;
pub use config::{Config, DebugLevel, Flags};

#[cfg(feature = "sync")]
pub trait MaybeSyncSend: Sync + Send {}

#[cfg(feature = "sync")]
impl<T: Sync + Send> MaybeSyncSend for T {}

#[cfg(not(feature = "sync"))]
pub trait MaybeSyncSend {}

#[cfg(not(feature = "sync"))]
impl<T> MaybeSyncSend for T {}

fn canonicalize_id<L: Language, N: Analysis<L>>(id: Id, egraph: &EGraph<L, N>) -> Id {
    let nid = egraph.find(id);

    #[cfg(debug_assertions)]
    if nid != id {
        println!("mapped {id:} to {nid:}")
    }
    nid
}

/// canonicalize `id`, returns `true` if the value changed
#[inline]
fn canonicalize_id_mut<L: Language, N: Analysis<L>>(id: &mut Id, egraph: &EGraph<L, N>) -> bool {
    let nid = egraph.find(*id);
    let res = nid != *id;

    #[cfg(debug_assertions)]
    if res {
        println!("updated id from {id} to {nid}")
    }

    *id = nid;
    res
}
